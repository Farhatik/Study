TARGETS = 01-base-addr 01-pie-32 02-data-data 02-data-bss 03-main 04-apb-1 05-apb-2 06-apb-3 07-sum-1 08-sum-2

all : $(TARGETS)

# В этом примере исполняемый код программы будет размещаться в
# адресном пространстве начиная с адреса 0xa0000000 вместо стандартного адреса 0x08048000
# Посмотреть можно с помощью команды 'objdump -D -j .text 01-base-addr'
01-base-addr : 01-base-addr.c
	gcc $^ -m32 -O2 -g -Wl,-Ttext-segment=0xa0000000 -o$@

# В этом примере генерируется исполняемая программа, которая может загружаться в
# адресное пространство начиная с любого адреса, выровненного по 2^12
01-pie-32 : 01-base-addr.c
	gcc $^ -m32 -O2 -g -Wl,-pie -DPIC -fPIC -o$@

# 64-битный позиционно-независимый код проще, чем 32-битный,
# так как система команд x86_64 содержит специальные инструкции
01-pie-64 : 01-base-addr.c
	gcc $^ -m64 -O2 -g -Wl,-pie -DPIC -fPIC -o$@

# В этом примере массив инициализируется ненулевым значением
# поэтому массив будет размещен в секции .data
# из-за чего исполняемый файл будет большим
02-data-data : 02-data.c
	gcc -Wall -O2 -DINIT_VALUE=1 $^ -o$@

# В этом примере массив инициализируется нулями
# поэтому массив будет размещен в секции .bss
# исполняемый файл будет существенно меньше
02-data-bss : 02-data.c
	gcc -Wall -O2 $^ -o$@

# В этом примере файл на Си и файл на ассемблере компонуются в одну
# исполняемую программу
03-main : 03-main.c 03-asm-data.S
	gcc -m32 -Wall -O2 $^ -o$@

# Первый пример программы на ассемблере
# Используем подпрограммы из simpleio_i686.S для упрощения ввода-вывода
04-apb-1 : 04-apb-1.S simpleio_i686.S
	gcc -m32 -Wall -O2 $^ -o$@

# Второй пример
# Размещаем временные значения на регистрах процессора
# Используем подпрограммы из simpleio_i686.S для упрощения ввода-вывода
05-apb-2 : 05-apb-2.S simpleio_i686.S
	gcc -m32 -Wall -O2 $^ -o$@

# Третий пример: программа для 64-битной ISA x86_64
# Используем подпрограммы из simpleio_x86_64.S для упрощения ввода-вывода
06-apb-3 : 06-apb-3.S simpleio_x86_64.S
	gcc -m64 -Wall -O2 $^ -o$@

# Пример на цикл
07-sum-1 : 07-sum-1.S simpleio_i686.S
	gcc -m32 -Wall -O2 $^ -o$@

# Другой пример на условные переходы
08-sum-2 : 08-sum-2.S simpleio_i686.S
	gcc -m32 -Wall -O2 $^ -o$@

clean :
	-rm -f $(TARGETS)